# 配置硬件参数

<cite>
**本文档引用的文件**   
- [config.h](file://main/boards/atk-dnesp32s3/config.h)
- [config.json](file://main/boards/atk-dnesp32s3/config.json)
- [resource_config.h](file://main/config/resource_config.h)
- [resource_config.cc](file://main/config/resource_config.cc)
- [config_api.h](file://main/config/config_api.h)
- [config_api.cc](file://main/config/config_api.cc)
- [application.h](file://main/application.h)
- [main.cc](file://main/main.cc)
</cite>

## 目录
1. [引言](#引言)
2. [项目结构](#项目结构)
3. [核心组件](#核心组件)
4. [架构概述](#架构概述)
5. [详细组件分析](#详细组件分析)
6. [依赖分析](#依赖分析)
7. [性能考虑](#性能考虑)
8. [故障排除指南](#故障排除指南)
9. [结论](#结论)

## 引言
本文档系统性地介绍了 `config.h` 和 `config.json` 两个配置文件的使用方法。`config.h` 文件用于定义编译期常量，如屏幕分辨率、I2C地址、音频采样率等硬件相关参数。`config.json` 文件则用于定义运行时可动态加载的配置信息，如板卡名称、版本、显示类型、音频芯片等。开发者需要根据实际硬件规格准确填写这些参数，以确保系统能够正确初始化和运行。`config.json` 中的信息将被 `Application` 单例读取，用于动态配置系统行为。本文档还提供了验证配置正确性的方法，如通过日志输出确认参数加载结果。

## 项目结构
项目采用基于功能的文件组织方式，主要模块包括 `main`、`scripts`、`xiaozhi-fonts` 等。`main` 目录下包含 `boards` 子目录，每个硬件板级支持一个独立的子目录，其中包含 `config.h` 和 `config.json` 两个核心配置文件。`config` 目录下包含 `resource_config.h` 和 `resource_config.cc`，实现了配置管理器单例，负责加载、保存、验证和调整配置参数。

```mermaid
graph TB
subgraph "main"
subgraph "boards"
atk-dnesp32s3["atk-dnesp32s3"]
esp-box["esp-box"]
bread-compact-esp32-lcd["bread-compact-esp32-lcd"]
atk-dnesp32s3 --> config_h["config.h"]
atk-dnesp32s3 --> config_json["config.json"]
esp-box --> config_h
esp-box --> config_json
bread-compact-esp32-lcd --> config_h
bread-compact-esp32-lcd --> config_json
end
subgraph "config"
resource_config_h["resource_config.h"]
resource_config_cc["resource_config.cc"]
end
subgraph "application"
application_h["application.h"]
application_cc["application.cc"]
end
main_cc["main.cc"]
end
main_cc --> application_h
application_h --> resource_config_h
resource_config_h --> resource_config_cc
```

**图示来源**
- [main.cc](file://main/main.cc)
- [application.h](file://main/application.h)
- [resource_config.h](file://main/config/resource_config.h)
- [resource_config.cc](file://main/config/resource_config.cc)

**本节来源**
- [main.cc](file://main/main.cc)
- [application.h](file://main/application.h)
- [resource_config.h](file://main/config/resource_config.h)
- [resource_config.cc](file://main/config/resource_config.cc)

## 核心组件
核心组件包括 `ConfigManager` 配置管理器单例和 `Application` 应用程序单例。`ConfigManager` 负责管理系统的运行时配置，提供加载、保存、验证和调整配置的功能。`Application` 是应用程序的主控制器，负责启动系统、管理设备状态和协调各个功能模块。

**本节来源**
- [resource_config.h](file://main/config/resource_config.h)
- [application.h](file://main/application.h)

## 架构概述
系统采用分层架构，上层为 `Application` 单例，负责业务逻辑和状态管理；中层为 `ConfigManager` 单例，负责配置管理；底层为硬件抽象层，通过 `config.h` 定义编译期常量。`Application` 在启动时会调用 `ConfigManager` 加载 `config.json` 文件中的配置，并根据配置动态调整系统行为。

```mermaid
graph TD
A["Application<br>应用程序单例"] --> B["ConfigManager<br>配置管理器单例"]
B --> C["config.json<br>运行时配置文件"]
B --> D["resource_config.h/cc<br>配置结构定义"]
A --> E["main.cc<br>程序入口"]
E --> A
F["config.h<br>编译期常量"] --> A
```

**图示来源**
- [application.h](file://main/application.h)
- [resource_config.h](file://main/config/resource_config.h)
- [main.cc](file://main/main.cc)

## 详细组件分析

### ConfigManager 配置管理器分析
`ConfigManager` 是一个单例类，负责管理系统的运行时配置。它通过 `load_config` 方法从 `config.json` 文件中加载配置，并通过 `validate_config` 方法验证配置的有效性。如果配置验证失败，将使用默认配置。

#### 类图
```mermaid
classDiagram
class ConfigManager {
+static GetInstance() ConfigManager&
+load_config(config_path) bool
+save_config(config_path) bool
+validate_config() bool
+reset_to_defaults() void
+adjust_for_device() void
-config_ ResourceConfig
}
class ResourceConfig {
+network Network
+memory Memory
+filesystem FileSystem
+image Image
+download_mode DownloadMode
+preload Preload
+debug Debug
+get_image_size() uint32_t
+get_total_images_size() uint32_t
+get_logo_path() std : : string
+get_packed_path() std : : string
+get_image_filename(index) std : : string
}
class Network {
+timeout_ms uint32_t
+retry_count uint32_t
+retry_delay_ms uint32_t
+buffer_size uint32_t
+connection_delay_ms uint32_t
+enable_keep_alive bool
}
class Memory {
+allocation_threshold uint32_t
+download_threshold uint32_t
+preload_threshold uint32_t
+buffer_pool_size uint32_t
+enable_memory_pool bool
}
class FileSystem {
+base_path std : : string
+image_path std : : string
+cache_path std : : string
+logo_filename std : : string
+packed_filename std : : string
+max_files uint32_t
+format_on_mount_fail bool
}
class Image {
+max_image_count uint32_t
+image_width uint32_t
+image_height uint32_t
+bytes_per_pixel uint32_t
+enable_format_conversion bool
+enable_packed_loading bool
}
class DownloadMode {
+disable_power_save bool
+pause_audio bool
+boost_task_priority bool
+gc_interval_ms uint32_t
+network_stabilize_ms uint32_t
}
class Preload {
+check_interval uint32_t
+load_delay_ms uint32_t
+progress_update_threshold uint32_t
+enable_silent_preload bool
+time_budget_ms uint32_t
}
class Debug {
+enable_file_verification bool
+verbose_logging bool
+enable_memory_tracking bool
+enable_performance_metrics bool
}
ConfigManager --> ResourceConfig : "包含"
ResourceConfig --> Network : "包含"
ResourceConfig --> Memory : "包含"
ResourceConfig --> FileSystem : "包含"
ResourceConfig --> Image : "包含"
ResourceConfig --> DownloadMode : "包含"
ResourceConfig --> Preload : "包含"
ResourceConfig --> Debug : "包含"
```

**图示来源**
- [resource_config.h](file://main/config/resource_config.h)
- [resource_config.cc](file://main/config/resource_config.cc)

### Application 应用程序分析
`Application` 是应用程序的主控制器，通过 `Start` 方法启动系统。在启动过程中，它会初始化事件循环、NVS闪存，并最终调用 `Start` 方法启动应用程序。

#### 序列图
```mermaid
sequenceDiagram
participant main as "main.cc"
participant Application as "Application"
participant ConfigManager as "ConfigManager"
main->>Application : app_main()
Application->>Application : Start()
Application->>ConfigManager : GetInstance()
ConfigManager->>ConfigManager : load_config()
ConfigManager->>ConfigManager : validate_config()
alt 配置有效
ConfigManager-->>Application : 返回成功
Application->>Application : 初始化其他组件
else 配置无效
ConfigManager->>ConfigManager : reset_to_defaults()
ConfigManager->>ConfigManager : adjust_for_device()
ConfigManager-->>Application : 返回成功
Application->>Application : 初始化其他组件
end
Application-->>main : 启动完成
```

**图示来源**
- [main.cc](file://main/main.cc)
- [application.h](file://main/application.h)
- [resource_config.h](file://main/config/resource_config.h)
- [resource_config.cc](file://main/config/resource_config.cc)

**本节来源**
- [main.cc](file://main/main.cc)
- [application.h](file://main/application.h)
- [resource_config.h](file://main/config/resource_config.h)
- [resource_config.cc](file://main/config/resource_config.cc)

## 依赖分析
系统的主要依赖关系如下：`main.cc` 依赖 `application.h`，`application.h` 依赖 `resource_config.h`，`resource_config.h` 定义了 `ResourceConfig` 结构和 `ConfigManager` 类。`ConfigManager` 的实现依赖 `resource_config.cc`。

```mermaid
graph LR
A["main.cc"] --> B["application.h"]
B --> C["resource_config.h"]
C --> D["resource_config.cc"]
```

**图示来源**
- [main.cc](file://main/main.cc)
- [application.h](file://main/application.h)
- [resource_config.h](file://main/config/resource_config.h)
- [resource_config.cc](file://main/config/resource_config.cc)

**本节来源**
- [main.cc](file://main/main.cc)
- [application.h](file://main/application.h)
- [resource_config.h](file://main/config/resource_config.h)
- [resource_config.cc](file://main/config/resource_config.cc)

## 性能考虑
`ConfigManager` 提供了 `adjust_for_device` 方法，可以根据设备的可用内存自动调整配置参数。例如，在内存小于1MB的设备上，会减小网络缓冲区大小和内存阈值，以适应内存受限的环境。

## 故障排除指南
当配置加载失败时，系统会输出相应的错误日志。例如，如果 `config.json` 文件解析失败，会输出 "配置文件JSON解析失败" 的错误日志，并使用默认配置。开发者可以通过查看日志来判断配置是否加载成功。

**本节来源**
- [resource_config.cc](file://main/config/resource_config.cc)

## 结论
`config.h` 和 `config.json` 是系统中两个重要的配置文件。`config.h` 用于定义编译期常量，`config.json` 用于定义运行时可动态加载的配置。`ConfigManager` 单例负责管理 `config.json` 中的配置，`Application` 单例在启动时会加载并验证这些配置。开发者需要根据实际硬件规格准确填写这些参数，并通过日志输出确认配置加载结果。