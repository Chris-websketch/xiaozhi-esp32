# 系统服务

<cite>
**本文档中引用的文件**   
- [ota.h](file://main/ota.h) - *OTA更新服务接口*
- [ota.cc](file://main/ota.cc) - *OTA更新服务实现*
- [settings.h](file://main/settings.h) - *配置管理服务接口*
- [settings.cc](file://main/settings.cc) - *配置管理服务实现*
- [error_handling.h](file://main/error/error_handling.h) - *错误处理服务接口*
- [error_handling.cc](file://main/error/error_handling.cc) - *错误处理服务实现*
- [application.cc](file://main/application.cc) - *主控模块实现*
- [application.h](file://main/application.h) - *主控模块接口*
- [image_manager.cc](file://main/image_manager.cc) - *图像资源管理器实现，包含存储管理功能*
- [image_manager.h](file://main/image_manager.h) - *图像资源管理器接口，包含存储管理方法声明*
- [system_info.cc](file://main/system_info.cc) - *系统信息服务实现，包含地理位置获取功能*
- [system_info.h](file://main/system_info.h) - *系统信息服务接口，定义地理位置信息结构*
</cite>

## 更新摘要
**已做更改**   
- 在"主控模块集成"章节新增"地理位置与时区管理"子章节，介绍设备地理位置获取和时区转换功能
- 添加新的序列图展示地理位置获取流程
- 更新文档引用文件列表，包含system_info.h和system_info.cc
- 在"更新摘要"中说明新增功能

## 目录
1. [系统服务](#系统服务)
2. [OTA更新服务](#ota更新服务)
3. [配置管理服务](#配置管理服务)
4. [错误处理服务](#错误处理服务)
5. [主控模块集成](#主控模块集成)
6. [安全更新与配置管理最佳实践](#安全更新与配置管理最佳实践)

## OTA更新服务

OTA（Over-The-Air）更新服务由`Ota`类实现，负责设备固件的远程升级。该服务通过HTTP请求检查新版本，下载固件并安全烧录，最后自动重启设备。

```
mermaid
sequenceDiagram
participant Application as Application
participant Ota as Ota
participant HTTP as HTTP Client
participant ESP as ESP32 OTA
Application->>Ota : CheckVersion()
Ota->>HTTP : 发送版本检查请求
HTTP-->>Ota : 返回JSON响应
Ota->>Ota : 解析响应并比较版本
alt 有新版本
Ota-->>Application : HasNewVersion() = true
Application->>Ota : StartUpgrade(callback)
Ota->>ESP : 启动OTA升级流程
ESP->>ESP : 下载固件
ESP->>ESP : 校验完整性
ESP->>ESP : 安全烧录
ESP->>ESP : 自动重启
else 无新版本
Ota-->>Application : HasNewVersion() = false
Ota->>Ota : MarkCurrentVersionValid()
end
```

**Diagram sources**
- [ota.h](file://main/ota.h#L1-L54)
- [ota.cc](file://main/ota.cc#L1-L367)

**Section sources**
- [ota.h](file://main/ota.h#L1-L54)
- [ota.cc](file://main/ota.cc#L1-L367)

### 版本检查与差分包下载

`Ota`类通过`CheckVersion()`方法发起版本检查。该方法向预设的URL发送HTTP请求，获取包含新固件版本和下载链接的JSON响应。代码中使用`cJSON_Parse`解析响应，并通过`IsNewVersionAvailable()`方法比较当前版本与服务器版本。

```cpp
bool Ota::CheckVersion() {
    // ... 创建HTTP请求 ...
    http->SetHeader("Ota-Version", "2");
    http->SetHeader("Device-Id", SystemInfo::GetMacAddress().c_str());
    // ... 发送请求并获取响应 ...
    cJSON *root = cJSON_Parse(response.c_str());
    // ... 解析JSON ...
    firmware_version_ = version->valuestring;
    firmware_url_ = url->valuestring;
    has_new_version_ = IsNewVersionAvailable(current_version_, firmware_version_);
    return true;
}
```

### 完整性校验与安全烧录

在固件下载过程中，系统通过文件头校验确保完整性。`image_manager.cc`中的代码会检查下载文件的魔数（magic number）是否匹配预定义的`BINARY_IMAGE_MAGIC`，以验证文件格式的正确性。

```cpp
if (fread(&verify_header, sizeof(BinaryImageHeader), 1, verify_file) == 1) {
    if (verify_header.magic == BINARY_IMAGE_MAGIC) {
        ESP_LOGI(TAG, "下载的二进制文件格式验证成功: %s", filepath);
        file_valid = true;
    } else {
        ESP_LOGW(TAG, "下载的文件魔数不匹配，可能是原始RGB数据: %s", filepath);
        file_valid = true;
    }
}
```

安全烧录由ESP32的OTA API处理。`Upgrade()`方法调用`esp_ota_get_next_update_partition()`获取更新分区，并通过`esp_ota_begin()`、`esp_ota_write()`和`esp_ota_end()`完成烧录。最后调用`esp_ota_set_boot_partition()`设置下次启动分区。

```
mermaid
flowchart TD
A[开始OTA升级] --> B[获取更新分区]
B --> C{分区有效?}
C --> |是| D[开始OTA会话]
C --> |否| E[记录错误并返回]
D --> F[下载固件块]
F --> G[写入OTA分区]
G --> H{全部写入?}
H --> |否| F
H --> |是| I[结束OTA会话]
I --> J[设置启动分区]
J --> K[重启设备]
```

**Diagram sources**
- [ota.cc](file://main/ota.cc#L231-L367)
- [image_manager.cc](file://main/image_manager.cc#L1080-L1120)

## 配置管理服务

配置管理服务由`Settings`类实现，利用ESP32的NVS（Non-Volatile Storage）功能提供持久化存储，用于保存用户设置和设备状态。

```
mermaid
classDiagram
class Settings {
+GetString(key, default)
+SetString(key, value)
+GetInt(key, default)
+SetInt(key, value)
+EraseKey(key)
+EraseAll()
}
Settings --> "NVS Flash" : 使用
```

**Diagram sources**
- [settings.h](file://main/settings.h#L1-L27)
- [settings.cc](file://main/settings.cc#L1-L88)

**Section sources**
- [settings.h](file://main/settings.h#L1-L27)
- [settings.cc](file://main/settings.cc#L1-L88)

### 持久化存储机制

`Settings`类在构造时通过`nvs_open()`打开指定命名空间的NVS句柄。读写操作分别调用`nvs_get_str()`/`nvs_set_str()`和`nvs_get_i32()`/`nvs_set_i32()`。写操作会标记`dirty_`标志，析构时若存在未提交的更改，则调用`nvs_commit()`保存。

```cpp
Settings::Settings(const std::string& ns, bool read_write) : ns_(ns), read_write_(read_write) {
    nvs_open(ns.c_str(), read_write_ ? NVS_READWRITE : NVS_READONLY, &nvs_handle_);
}

std::string Settings::GetString(const std::string& key, const std::string& default_value) {
    // ... 调用nvs_get_str() ...
}

void Settings::SetString(const std::string& key, const std::string& value) {
    if (read_write_) {
        ESP_ERROR_CHECK(nvs_set_str(nvs_handle_, key.c_str(), value.c_str()));
        dirty_ = true;
    }
}
```

### 存储空间管理

图像资源管理器新增了存储空间管理功能，包括临时文件清理、空间碎片优化、可用空间查询和分区格式化重置。这些功能确保了SPIFFS文件系统的稳定性和可靠性。

```
mermaid
sequenceDiagram
participant Application as Application
participant ImageManager as ImageResourceManager
participant SPIFFS as SPIFFS
Application->>ImageManager : GetSpiffsFreeSpace()
ImageManager->>SPIFFS : 查询空间信息
SPIFFS-->>ImageManager : 返回总空间和已用空间
ImageManager-->>Application : 返回可用空间
Application->>ImageManager : CleanupTemporaryFiles()
ImageManager->>ImageManager : 扫描临时文件
ImageManager->>ImageManager : 删除.tmp/.bak等临时文件
ImageManager->>ImageManager : 清理损坏的缓存文件
ImageManager-->>Application : 返回清理结果
Application->>ImageManager : OptimizeSpiffsSpace()
ImageManager->>SPIFFS : 创建临时文件触发垃圾回收
ImageManager->>SPIFFS : 多次创建删除小文件优化碎片
ImageManager-->>Application : 返回优化结果
alt 空间严重不足
Application->>ImageManager : FormatResourcesPartition()
ImageManager->>ImageManager : 重置内存状态
ImageManager->>SPIFFS : 卸载resources分区
ImageManager->>SPIFFS : 格式化分区
ImageManager->>SPIFFS : 重新挂载分区
ImageManager->>ImageManager : 创建必要目录
ImageManager-->>Application : 返回格式化结果
end
```

**Diagram sources**
- [image_manager.h](file://main/image_manager.h#L130-L133) - *存储管理方法声明*
- [image_manager.cc](file://main/image_manager.cc#L3413-L3662) - *存储管理方法实现*

**Section sources**
- [image_manager.h](file://main/image_manager.h#L130-L133)
- [image_manager.cc](file://main/image_manager.cc#L3413-L3662)

`GetSpiffsFreeSpace()`方法查询SPIFFS文件系统的可用空间，帮助系统决策是否需要清理或优化。

```cpp
size_t ImageResourceManager::GetSpiffsFreeSpace() {
    if (!mounted_) {
        ESP_LOGW(TAG, "SPIFFS未挂载，无法获取空间信息");
        return 0;
    }
    
    size_t total = 0, used = 0;
    esp_err_t ret = esp_spiffs_info("resources", &total, &used);
    if (ret != ESP_OK) {
        ESP_LOGE(TAG, "获取SPIFFS空间信息失败: %s", esp_err_to_name(ret));
        return 0;
    }
    
    return (total > used) ? (total - used) : 0;
}
```

`CleanupTemporaryFiles()`方法清理临时文件和损坏文件，包括.tmp、.bak等扩展名的文件以及大小为0的JSON缓存文件。

`OptimizeSpiffsSpace()`方法通过创建和删除临时文件来触发SPIFFS的垃圾回收机制，优化空间碎片，提高存储效率。

`FormatResourcesPartition()`方法在极端情况下强制格式化重置resources分区，删除所有数据并重新创建文件系统，以解决严重的存储问题。

## 错误处理服务

错误处理服务由`ImageResource`命名空间下的`error_handling.h`和`error_handling.cc`实现，提供了一套现代化的错误码定义、异常传播和恢复机制。

```
mermaid
classDiagram
class ErrorCode {
+Success
+InvalidArgument
+NoMemory
+NetworkTimeout
+FileNotFound
+ImageFormatUnsupported
+MemoryAllocationFailed
+MemoryCorrupted
+ResourceNotInitialized
+ResourceAlreadyExists
+ResourceVersionMismatch
+ResourceQuotaExceeded
+Unknown
}
class ErrorInfo {
+code : ErrorCode
+message : const char*
+context : const char*
+context_data : uint32_t
}
class Result~T~ {
+is_success()
+is_error()
+value()
+error()
+value_or(default)
+map(func)
+recover(recovery_func)
}
class ErrorRecoveryStrategy {
+recover(error)
+can_handle(code)
}
class RetryStrategy {
+max_retries_
+delay_ms_
+current_retries_
}
class ErrorHandler {
+GetInstance()
+register_strategy(code, strategy)
+handle_error(error)
+log_error(error)
}
Result~T~ --> ErrorInfo : 包含
ErrorRecoveryStrategy <|-- RetryStrategy : 继承
ErrorHandler --> ErrorRecoveryStrategy : 拥有
ErrorHandler --> ErrorInfo : 使用
```

**Diagram sources**
- [error_handling.h](file://main/error/error_handling.h#L1-L351)
- [error_handling.cc](file://main/error/error_handling.cc#L1-L136)

**Section sources**
- [error_handling.h](file://main/error/error_handling.h#L1-L351)
- [error_handling.cc](file://main/error/error_handling.cc#L1-L136)

### 错误码定义与异常传播

错误码`ErrorCode`以`enum class`形式定义，继承自`esp_err_t`并扩展了网络、文件系统、图片处理等领域的特定错误。`ErrorInfo`结构体封装了错误码、消息、上下文和附加数据，优化了内存占用。

`Result<T>`模板类实现了类似Rust的`Result<T, E>`模式，用于安全地传播错误。`is_success()`和`is_error()`方法检查结果状态，`value()`和`error()`分别获取成功值或错误信息。

```cpp
template<typename T>
class Result {
public:
    static Result success(T&& value);
    static Result error(const ErrorInfo& error);
    bool is_success() const;
    bool is_error() const;
    const T& value() const;
    const ErrorInfo& error() const;
};
```

### 错误恢复流程

`ErrorHandler`单例管理错误恢复策略。`RetryStrategy`实现了针对网络超时、连接失败等可重试错误的自动重试机制。当`handle_error()`被调用时，处理器会查找注册的策略并执行恢复操作。

```cpp
Result<void> RetryStrategy::recover(const ErrorInfo& error) {
    if (current_retries_ >= max_retries_) {
        return Result<void>::error(error);
    }
    current_retries_++;
    vTaskDelay(pdMS_TO_TICKS(delay_ms_));
    return Result<void>::success();
}
```

## 主控模块集成

主控模块`Application`负责集成和调度OTA、配置管理和错误处理三大服务。它通过成员变量持有这些服务的实例，并在启动流程中协调它们的工作。

```
mermaid
classDiagram
class Application {
+GetOta() : Ota&
+GetDeviceConfig() : DeviceConfig
+CheckNewVersion()
+Schedule(callback)
+SetDeviceState(state)
}
Application --> Ota : 拥有
Application --> Settings : 间接使用
Application --> ErrorHandler : 间接使用
Application --> Board : 依赖
Application --> Display : 依赖
```

**Diagram sources**
- [application.h](file://main/application.h#L1-L228)
- [application.cc](file://main/application.cc#L1-L1825)

**Section sources**
- [application.h](file://main/application.h#L1-L228)
- [application.cc](file://main/application.cc#L1-L1825)

`Application::CheckNewVersion()`方法是OTA流程的入口。它循环调用`ota_.CheckVersion()`，若检测到新版本，则通过`Schedule()`在主线程中启动升级流程，并更新设备状态为`kDeviceStateUpgrading`。

```cpp
void Application::CheckNewVersion() {
    while (true) {
        if (!ota_.CheckVersion()) {
            // ... 重试逻辑 ...
            continue;
        }
        if (ota_.HasNewVersion()) {
            Schedule([this]() {
                SetDeviceState(kDeviceStateUpgrading);
                ota_.StartUpgrade([display](int progress, size_t speed) {
                    // 更新进度显示
                });
            });
            return;
        }
        ota_.MarkCurrentVersionValid();
        break;
    }
}
```

### 地理位置与时区管理

系统新增了设备地理位置获取和时区自动转换功能。`Application::CheckNewVersion()`在启动时调用`SystemInfo::GetCountryInfo()`从ipinfo.io获取设备的IP地址和国家代码。获取的地理位置信息被缓存5分钟，避免频繁请求。

```
mermaid
sequenceDiagram
participant Application as Application
participant SystemInfo as SystemInfo
participant HTTP as HTTP Client
participant Cache as Location Cache
Application->>SystemInfo : GetCountryInfo()
alt 缓存有效
SystemInfo->>Cache : 检查缓存
Cache-->>SystemInfo : 返回缓存结果
SystemInfo-->>Application : 返回地理位置信息
else 缓存无效
SystemInfo->>SystemInfo : 检查WiFi连接
SystemInfo->>HTTP : 发送GET请求到ipinfo.io/json
HTTP-->>SystemInfo : 返回JSON响应
SystemInfo->>SystemInfo : 解析IP和国家代码
SystemInfo->>SystemInfo : 查询时区偏移
SystemInfo->>Cache : 更新缓存
SystemInfo-->>Application : 返回地理位置信息
end
```

**Diagram sources**
- [system_info.h](file://main/system_info.h#L1-L85) - *地理位置信息结构定义*
- [system_info.cc](file://main/system_info.cc#L300-L450) - *地理位置获取和时区转换实现*
- [application.cc](file://main/application.cc#L150-L170) - *地理位置获取调用*

**Section sources**
- [system_info.h](file://main/system_info.h#L1-L85)
- [system_info.cc](file://main/system_info.cc#L300-L450)
- [application.cc](file://main/application.cc#L150-L170)

`GetCountryInfo()`方法首先检查WiFi连接状态，然后向ipinfo.io发送HTTP请求获取地理位置信息。解析响应后，通过`GetTimezoneOffset()`方法根据国家代码查找对应的时区偏移（UTC小时数）。系统维护了一个国家代码到时区偏移的映射表，覆盖了全球主要国家和地区。

```cpp
GeoLocationInfo SystemInfo::GetCountryInfo() {
    // 检查缓存
    static GeoLocationInfo cached_result;
    static bool cache_initialized = false;
    static uint32_t last_request_time = 0;
    
    uint32_t current_time = xTaskGetTickCount() * portTICK_PERIOD_MS;
    
    // 5分钟缓存
    if (cache_initialized && cached_result.is_valid && 
        (current_time - last_request_time) < 300000) {
        return cached_result;
    }
    
    // ... 发送HTTP请求获取地理位置 ...
    
    // 验证结果并更新缓存
    if (!result.ip_address.empty() && !result.country_code.empty()) {
        result.is_valid = true;
        result.timezone_offset = GetTimezoneOffset(result.country_code);
        cached_result = result;
        cache_initialized = true;
        last_request_time = current_time;
    }
    
    return result;
}
```

`ConvertFromBeijingTime()`方法实现了从北京时间（UTC+8）到目标时区的时间转换。该方法将`struct tm`时间结构转换为`time_t`进行计算，加上时区差异后，再转换回`struct tm`格式。

## 安全更新与配置管理最佳实践

### OTA安全更新最佳实践

尽管代码中未直接实现签名验证，但系统通过以下机制保障OTA更新的安全性：
1. **完整性校验**：下载的固件文件通过魔数校验确保格式正确。
2. **回滚机制**：利用ESP32的OTA分区机制，若新固件启动失败，系统会自动回滚到之前的稳定版本。
3. **状态标记**：`MarkCurrentVersionValid()`方法在确认新固件运行正常后，将其标记为有效，防止无限回滚。

```cpp
void Ota::MarkCurrentVersionValid() {
    esp_ota_img_states_t state;
    if (esp_ota_get_state_partition(partition, &state) != ESP_OK) {
        return;
    }
    if (state == ESP_OTA_IMG_PENDING_VERIFY) {
        esp_ota_mark_app_valid_cancel_rollback();
    }
}
```

### 配置项管理指南

添加新的配置参数需遵循以下步骤：
1. 在`ResourceConfig`结构体中定义新的配置项。
2. 在`ConfigManager::load_config()`中添加JSON解析逻辑。
3. 在`ConfigManager::validate_config()`中添加参数有效性验证。
4. 在`ConfigManager::reset_to_defaults()`中设置默认值。

```cpp
// 示例：在resource_config.h中添加新配置
struct NetworkConfig {
    uint32_t timeout_ms;
    uint32_t retry_count;
    uint32_t buffer_size;
    // 新增配置项
    uint32_t connection_delay_ms;
};

// 在resource_config.cc中解析
if ((item = cJSON_GetObjectItem(network, "connection_delay_ms"))) {
    config_.network.connection_delay_ms = item->valueint;
}
```

**Section sources**
- [config/resource_config.h](file://main/config/resource_config.h#L259-L337)
- [config/resource_config.cc](file://main/config/resource_config.cc#L44-L153)