# 物联网功能

<cite>
**本文档中引用的文件**   
- [thing.h](file://main/iot/thing.h)
- [thing.cc](file://main/iot/thing.cc)
- [thing_manager.h](file://main/iot/thing_manager.h)
- [thing_manager.cc](file://main/iot/thing_manager.cc)
- [music_player.cc](file://main/iot/things/music_player.cc)
- [music_player.h](file://main/iot/things/music_player.h)
- [battery.cc](file://main/iot/things/battery.cc)
- [lamp.cc](file://main/iot/things/lamp.cc)
- [mqtt_notifier.cc](file://main/notifications/mqtt_notifier.cc)
- [application.cc](file://main/application.cc)
- [application.h](file://main/application.h)
- [mqtt_set.md](file://main/notifications/mqtt_set.md)
</cite>

## 更新摘要
**已更新内容**
- 在“设备控制流程”章节中，新增了关于MQTT通知服务的启动和停止机制，以支持省电模式下的网络资源管理
- 更新了“设备控制流程”中的序列图，以反映在省电模式下MQTT服务的生命周期管理
- 在“设备控制流程”章节中，补充了`StopMqttNotifier`和`StartMqttNotifier`方法的实现细节及其在省电模式中的应用
- 更新了相关文件的引用，以包含`application.cc`和`application.h`中的新内容

## 目录
1. [物联网设备模型概述](#物联网设备模型概述)
2. [设备管理器与设备注册](#设备管理器与设备注册)
3. [设备类型自动注册机制](#设备类型自动注册机制)
4. [设备控制流程](#设备控制流程)
5. [自定义物联网设备开发指南](#自定义物联网设备开发指南)
6. [具体设备实现分析：音乐播放器](#具体设备实现分析音乐播放器)

## 物联网设备模型概述

物联网设备模型的核心是 `Thing` 抽象基类，它定义了所有物联网设备的通用接口和行为。该模型采用面向对象的设计，通过继承机制实现不同类型的设备。

### Thing 类结构

`Thing` 类是所有具体设备类型的基类，它封装了设备的名称、描述、可查询属性（Properties）和可执行方法（Methods）。

```
classDiagram
class Thing {
+string name()
+string description()
+string GetDescriptorJson()
+string GetStateJson()
+void Invoke(const cJSON* command)
+bool InvokeSync(const cJSON* command, string* error)
}
class PropertyList {
+AddBooleanProperty(name, desc, getter)
+AddNumberProperty(name, desc, getter)
+AddStringProperty(name, desc, getter)
+GetDescriptorJson()
+GetStateJson()
}
class MethodList {
+AddMethod(name, desc, params, callback)
+GetDescriptorJson()
}
class Property {
+string name()
+string description()
+ValueType type()
+bool boolean()
+int number()
+string string()
}
class Method {
+string name()
+string description()
+ParameterList& parameters()
+GetDescriptorJson()
+Invoke()
}
class ParameterList {
+AddParameter(param)
+GetDescriptorJson()
}
class Parameter {
+string name()
+string description()
+ValueType type()
+bool required()
+set_boolean(value)
+set_number(value)
+set_string(value)
}
Thing --> PropertyList : "拥有"
Thing --> MethodList : "拥有"
MethodList --> Method : "包含"
Method --> ParameterList : "拥有"
ParameterList --> Parameter : "包含"
PropertyList --> Property : "包含"
```

**Diagram sources**
- [thing.h](file://main/iot/thing.h#L0-L302)

**Section sources**
- [thing.h](file://main/iot/thing.h#L0-L302)

### 属性（Property）系统

属性系统用于描述设备的可查询状态。每个属性都有一个名称、描述、数据类型和一个获取器函数（getter），该函数在查询时被调用以返回当前值。

```cpp
// 属性定义示例 (来自 battery.cc)
properties_.AddNumberProperty("level", "当前电量百分比", [this]() -> int {
    auto& board = Board::GetInstance();
    if (board.GetBatteryLevel(level_, charging_, discharging_)) {
        return level_;
    }
    return 0;
});
```

属性支持三种数据类型：
- **kValueTypeBoolean**: 布尔值
- **kValueTypeNumber**: 数值
- **kValueTypeString**: 字符串

属性的获取器函数使用 `std::function` 实现，可以是 lambda 表达式或成员函数，这使得属性值可以动态计算。

### 方法（Method）系统

方法系统用于定义设备可执行的操作。每个方法都有一个名称、描述、参数列表和一个回调函数。

```cpp
// 方法定义示例 (来自 lamp.cc)
methods_.AddMethod("TurnOn", "打开灯", ParameterList(), [this](const ParameterList& parameters) {
    power_ = true;
    gpio_set_level(gpio_num_, 1);
});
```

方法的回调函数在方法被调用时执行，通常用于控制硬件或改变设备状态。

## 设备管理器与设备注册

`ThingManager` 是一个单例类，负责管理所有注册的物联网设备实例，提供设备发现、状态同步和指令分发的功能。

### ThingManager 类结构

```
classDiagram
class ThingManager {
+static ThingManager& GetInstance()
+void AddThing(Thing* thing)
+string GetDescriptorsJson()
+bool GetStatesJson(string& json, bool delta = false)
+void Invoke(const cJSON* command)
+bool InvokeSync(const cJSON* command, string* error)
}
ThingManager --> Thing : "管理"
```

**Diagram sources**
- [thing_manager.h](file://main/iot/thing_manager.h#L0-L42)

**Section sources**
- [thing_manager.h](file://main/iot/thing_manager.h#L0-L42)

### 设备注册机制

设备通过 `AddThing` 方法注册到 `ThingManager` 中。一旦注册，设备就可以被发现和控制。

```cpp
// 设备注册示例
auto my_device = new iot::MyDevice();
iot::ThingManager::GetInstance().AddThing(my_device);
```

`ThingManager` 维护一个 `std::vector<Thing*>` 来存储所有注册的设备指针。

### 设备发现与状态同步

`ThingManager` 提供了两个关键方法用于设备发现和状态同步：

- **GetDescriptorsJson()**: 返回所有已注册设备的描述信息，包括它们的名称、描述、属性和方法。这用于让外部系统了解设备的能力。
- **GetStatesJson()**: 返回所有已注册设备的当前状态。支持增量模式（delta），只返回自上次调用以来状态发生变化的设备。

```cpp
// 状态同步示例
std::string states_json;
bool changed = iot::ThingManager::GetInstance().GetStatesJson(states_json, true);
if (changed) {
    // 将 states_json 发送到服务器
}
```

## 设备类型自动注册机制

`DECLARE_THING` 宏是实现设备类型自动注册和动态创建的核心机制。它利用了 C++ 的静态初始化特性。

### DECLARE_THING 宏解析

```cpp
#define DECLARE_THING(TypeName) \
    static iot::Thing* Create##TypeName() { \
        return new iot::TypeName(); \
    } \
    static bool Register##TypeNameHelper = []() { \
        RegisterThing(#TypeName, Create##TypeName); \
        return true; \
    }();
```

这个宏做了两件事：
1.  **定义创建函数**: `Create##TypeName()` 是一个静态函数，用于创建指定类型的 `Thing` 实例。
2.  **定义注册助手**: `Register##TypeNameHelper` 是一个静态布尔变量，其初始化器是一个立即执行的 lambda 函数。这个 lambda 函数会调用 `RegisterThing` 将类型名和创建函数注册到全局注册表中。

由于 `Register##TypeNameHelper` 是静态变量，它的初始化会在程序启动时、`main` 函数执行之前完成。这确保了所有使用 `DECLARE_THING` 宏的设备类型在程序运行初期就已经注册。

### 全局注册表

`thing_creators` 是一个全局的 `std::map`，它将设备类型名（字符串）映射到对应的创建函数（`std::function<Thing*()>`）。

```cpp
// thing.cc 中的全局变量
static std::map<std::string, std::function<Thing*()>>* thing_creators = nullptr;

// 注册函数
void RegisterThing(const std::string& type, std::function<Thing*()> creator) {
    if (thing_creators == nullptr) {
        thing_creators = new std::map<std::string, std::function<Thing*()>>();
    }
    (*thing_creators)[type] = creator;
}

// 创建函数
Thing* CreateThing(const std::string& type) {
    auto creator = thing_creators->find(type);
    if (creator == thing_creators->end()) {
        return nullptr;
    }
    return creator->second();
}
```

### 动态创建流程

1.  **注册**: 当一个设备类（如 `Battery`）在其源文件末尾使用 `DECLARE_THING(Battery)` 时，编译器会生成 `CreateBattery` 函数和 `RegisterBatteryHelper` 变量。
2.  **初始化**: 程序启动时，`RegisterBatteryHelper` 被初始化，其 lambda 函数执行，调用 `RegisterThing("Battery", CreateBattery)`，将 "Battery" 类型和 `CreateBattery` 函数存入 `thing_creators` 映射。
3.  **创建**: 在板级初始化代码中，调用 `iot::CreateThing("Battery")`。该函数在 `thing_creators` 映射中查找 "Battery"，找到后调用其对应的 `CreateBattery` 函数，从而动态创建一个 `Battery` 实例。

```cpp
// 在板级初始化中动态创建设备
auto battery = iot::CreateThing("Battery");
if (battery) {
    iot::ThingManager::GetInstance().AddThing(battery);
}
```

**Section sources**
- [thing.h](file://main/iot/thing.h#L289-L297)
- [thing.cc](file://main/iot/thing.cc#L0-L46)
- [battery.cc](file://main/iot/things/battery.cc#L34)

## 设备控制流程

设备控制流程是一个从外部指令接收到执行结果上报的完整闭环。

### 整体控制流程

```
sequenceDiagram
participant 外部系统 as 外部系统 (MQTT/WS)
participant 协议层 as 协议层 (MQTT/WS)
participant 设备管理器 as 设备管理器 (ThingManager)
participant 具体设备 as 具体设备 (Thing)
participant ACK确认 as ACK确认机制
外部系统->>协议层 : 发送JSON指令
协议层->>设备管理器 : 调用InvokeSync
设备管理器->>设备管理器 : 根据name查找设备
设备管理器->>具体设备 : 调用InvokeSync
具体设备->>具体设备 : 解析method和parameters
具体设备->>具体设备 : 调用对应方法的回调
具体设备->>具体设备 : 执行硬件控制
具体设备-->>设备管理器 : 返回执行结果
设备管理器-->>协议层 : 返回结果和错误信息
协议层->>ACK确认 : 调用PublishAck发送ACK
ACK确认->>ACK确认 : 生成message_id并发送
ACK确认-->>外部系统 : 发送带message_id的ACK
外部系统->>协议层 : 发送ack_receipt确认
协议层->>ACK确认 : 处理ack_receipt
ACK确认->>ACK确认 : 从待确认列表中移除
```

**Diagram sources**
- [mqtt_notifier.cc](file://main/notifications/mqtt_notifier.cc#L0-L44)
- [application.cc](file://main/application.cc#L760-L782)
- [thing_manager.cc](file://main/iot/thing_manager.cc#L42-L88)
- [thing.cc](file://main/iot/thing.cc#L73-L118)
- [mqtt_notifier.h](file://main/notifications/mqtt_notifier.h#L45-L104)
- [mqtt_set.md](file://main/notifications/mqtt_set.md#L264-L270)

**Section sources**
- [mqtt_notifier.cc](file://main/notifications/mqtt_notifier.cc#L0-L44)
- [application.cc](file://main/application.cc#L760-L782)
- [thing_manager.cc](file://main/iot/thing_manager.cc#L42-L88)
- [thing.cc](file://main/iot/thing.cc#L73-L118)
- [mqtt_notifier.h](file://main/notifications/mqtt_notifier.h#L45-L104)
- [mqtt_set.md](file://main/notifications/mqtt_set.md#L264-L270)

### 指令接收与分发

1.  **指令接收**: 外部系统（如服务器）通过 MQTT 或 WebSocket 发送一个 JSON 格式的指令。
    ```json
    {
      "type": "iot",
      "commands": [
        { "name": "Lamp", "method": "TurnOn", "parameters": {} }
      ]
    }
    ```
2.  **协议层处理**: `MqttNotifier` 或 `WebsocketProtocol` 接收消息，解析出 `type` 为 "iot"，然后将指令传递给上层协议处理。
3.  **调用设备管理器**: 协议层调用 `ThingManager::GetInstance().InvokeSync(command, &error)`。

### 指令解析与执行

1.  **设备查找**: `ThingManager::InvokeSync` 首先从指令中提取 `name` 字段，然后遍历其管理的设备列表，找到名称匹配的 `Thing` 实例。
2.  **方法查找**: `Thing::InvokeSync` 从指令中提取 `method` 字段，然后在自己的 `methods_` 列表中查找同名的方法。
3.  **参数解析**: 对于找到的方法，遍历其 `parameters_` 列表，从指令的 `parameters` 对象中提取对应的值，并调用 `set_*` 方法设置到 `Parameter` 对象中。
4.  **执行回调**: 调用 `Method` 对象的 `Invoke()` 方法，该方法会执行在 `AddMethod` 时注册的回调函数 `callback_`。

```cpp
// Thing::InvokeSync 的核心逻辑
auto& method = methods_[method_name->valuestring];
// ... 解析参数 ...
method.Invoke(); // 执行回调
```

### 执行结果上报与ACK确认机制

`InvokeSync` 方法返回一个布尔值表示执行是否成功。如果失败，会通过 `error` 参数返回错误信息。协议层会将这个结果封装成一个 ACK 消息发回给外部系统。

#### ACK消息生成与跟踪

1.  **生成消息ID**: `MqttNotifier::PublishAck` 方法在发送ACK前，会调用 `GenerateMessageId()` 生成一个唯一的消息ID（如 `msg_1704901234567_1`），并将其添加到ACK消息的 `message_id` 字段中。
2.  **加入待确认列表**: 发送ACK后，无论 `mqtt_->Publish` 是否成功，都会将该消息（包括payload、QoS、发送时间、重试次数）存入 `pending_acks_` 映射中，等待服务器确认。
3.  **启动监控任务**: `MqttNotifier` 在启动时会创建一个名为 `ack_monitor` 的FreeRTOS任务，该任务每5秒调用一次 `CheckPendingAcks()`。

```cpp
// mqtt_notifier.cc 中的ACK发送逻辑
std::string message_id = GenerateMessageId();
cJSON_AddStringToObject(root, "message_id", message_id.c_str());
{
    std::lock_guard<std::mutex> lock(pending_acks_mutex_);
    pending_acks_[message_id] = PendingAck(std::string(payload), attempt_qos);
}
bool ok = mqtt_->Publish(ack_topic_, payload, attempt_qos);
```

#### 超时重试机制

`CheckPendingAcks()` 任务负责监控所有待确认的ACK消息：

1.  **检查超时**: 遍历 `pending_acks_` 列表，检查每条消息的发送时间。如果超过 `ACK_TIMEOUT_MS`（10秒）仍未收到确认，则触发重试逻辑。
2.  **执行重试**: 如果重试次数小于 `MAX_ACK_RETRIES`（2次），则重新调用 `mqtt_->Publish` 发送该消息，并更新发送时间和递增重试计数。
3.  **永久失败**: 如果达到最大重试次数，该消息将从 `pending_acks_` 中移除，并记录错误日志。

```cpp
// mqtt_notifier.cc 中的超时检查逻辑
for (const auto& pair : pending_acks_) {
    auto duration_ms = std::chrono::duration_cast<std::chrono::milliseconds>(now - pair.second.sent_time).count();
    if (duration_ms > ACK_TIMEOUT_MS) {
        if (pair.second.retry_count < MAX_ACK_RETRIES) {
            to_retry.push_back(pair.first);
        } else {
            to_remove.push_back(pair.first);
            ESP_LOGE(TAG, "ACK permanently failed for message_id=%s after %d attempts", pair.first.c_str(), pair.second.retry_count + 1);
        }
    }
}
```

#### 服务器确认处理

当服务器成功处理ACK消息后，必须回复一个 `ack_receipt` 消息：

1.  **接收确认**: `MqttNotifier` 的消息回调会检测到 `type` 为 `ack_receipt` 的消息。
2.  **处理回复**: `HandleAckReceipt` 方法会解析 `message_id`，并在 `pending_acks_` 列表中查找对应的消息。
3.  **清理待确认项**: 找到后，从 `pending_acks_` 中移除该消息，停止其重试。

```cpp
// mqtt_notifier.cc 中的确认处理逻辑
void MqttNotifier::HandleAckReceipt(const cJSON* receipt) {
    cJSON* message_id_json = cJSON_GetObjectItem(receipt, "message_id");
    std::string message_id = message_id_json->valuestring;
    std::lock_guard<std::mutex> lock(pending_acks_mutex_);
    auto it = pending_acks_.find(message_id);
    if (it != pending_acks_.end()) {
        pending_acks_.erase(it);
        ESP_LOGI(TAG, "ACK confirmation received: message_id=%s", message_id.c_str());
    }
}
```

#### 省电模式下的MQTT服务管理

为了支持省电模式，系统新增了对MQTT通知服务的显式控制接口。当设备进入省电模式时，会调用 `StopMqttNotifier` 安全地关闭MQTT连接；当设备从省电模式恢复时，会调用 `StartMqttNotifier` 重新建立连接。

1.  **停止服务**: `StopMqttNotifier` 方法会删除MQTT客户端实例、停止心跳和ACK监控任务，并清理待确认的消息列表。
2.  **启动服务**: `StartMqttNotifier` 方法会重新加载配置、创建MQTT客户端、建立连接，并启动心跳和ACK监控任务。

```cpp
// application.cc 中的省电模式管理逻辑
void Application::StopMqttNotifier() {
    if (notifier_) {
        ESP_LOGI(TAG, "正在停止MQTT通知服务...");
        notifier_->Stop();
        ESP_LOGI(TAG, "MQTT通知服务已停止");
    }
}

void Application::StartMqttNotifier() {
    if (notifier_) {
        ESP_LOGI(TAG, "正在启动MQTT通知服务...");
        notifier_->Start();
        ESP_LOGI(TAG, "MQTT通知服务已启动");
    }
}
```

**Section sources**
- [mqtt_notifier.cc](file://main/notifications/mqtt_notifier.cc#L296-L465)
- [mqtt_notifier.h](file://main/notifications/mqtt_notifier.h#L45-L104)
- [mqtt_set.md](file://main/notifications/mqtt_set.md#L264-L270)
- [application.cc](file://main/application.cc#L1900-L1924)

## 自定义物联网设备开发指南

开发一个新的物联网设备需要遵循以下步骤。

### 开发步骤

1.  **创建设备类**: 创建一个新的 C++ 类，继承自 `iot::Thing`。
2.  **定义构造函数**: 在构造函数中调用基类构造函数，传入设备的名称和描述。
3.  **定义属性**: 使用 `properties_` 成员添加设备的可查询状态。
4.  **定义方法**: 使用 `methods_` 成员添加设备可执行的操作，并为每个方法提供回调函数。
5.  **实现硬件控制**: 在方法的回调函数中实现对硬件（如 GPIO、显示屏、音频等）的实际控制逻辑。
6.  **注册设备**: 使用 `DECLARE_THING` 宏或直接创建实例的方式将设备注册到系统中。

### 代码模板

```cpp
// my_device.h
#ifndef MY_DEVICE_H
#define MY_DEVICE_H

#include "iot/thing.h"

namespace iot {

class MyDevice : public Thing {
public:
    MyDevice();
private:
    // 硬件状态变量
    bool is_on_ = false;
    int brightness_ = 50;

    // 回调函数
    void HandleTurnOn(const ParameterList& params);
    void HandleTurnOff(const ParameterList& params);
    void HandleSetBrightness(const ParameterList& params);
};

} // namespace iot

#endif // MY_DEVICE_H
```

```cpp
// my_device.cc
#include "my_device.h"
#include "board.h" // 假设需要控制板级硬件

namespace iot {

MyDevice::MyDevice() : Thing("MyDevice", "我的自定义设备") {
    // 定义属性
    properties_.AddBooleanProperty("is_on", "设备是否开启", [this]() { return is_on_; });
    properties_.AddNumberProperty("brightness", "亮度", [this]() { return brightness_; });

    // 定义方法
    methods_.AddMethod("TurnOn", "打开设备", ParameterList(), [this](const ParameterList& params) {
        HandleTurnOn(params);
    });
    
    methods_.AddMethod("TurnOff", "关闭设备", ParameterList(), [this](const ParameterList& params) {
        HandleTurnOff(params);
    });
    
    ParameterList brightness_params;
    brightness_params.AddParameter(Parameter("level", "亮度等级", kValueTypeNumber));
    methods_.AddMethod("SetBrightness", "设置亮度", brightness_params, [this](const ParameterList& params) {
        HandleSetBrightness(params);
    });
}

void MyDevice::HandleTurnOn(const ParameterList& params) {
    is_on_ = true;
    // 实现打开硬件的逻辑
}

void MyDevice::HandleTurnOff(const ParameterList& params) {
    is_on_ = false;
    // 实现关闭硬件的逻辑
}

void MyDevice::HandleSetBrightness(const ParameterList& params) {
    try {
        brightness_ = params["level"].number();
        // 实现设置亮度的逻辑
    } catch (const std::exception& e) {
        ESP_LOGE("MyDevice", "SetBrightness: 参数缺失");
    }
}

} // namespace iot

// 使用 DECLARE_THING 宏自动注册
DECLARE_THING(MyDevice);
```

### 设备注册方式

有两种方式将设备实例添加到 `ThingManager`：

1.  **使用 DECLARE_THING 宏 (推荐)**:
    ```cpp
    // 在 my_device.cc 末尾
    DECLARE_THING(MyDevice);
    
    // 在板级初始化代码中
    auto my_device = iot::CreateThing("MyDevice");
    if (my_device) {
        iot::ThingManager::GetInstance().AddThing(my_device);
    }
    ```
2.  **直接创建实例**:
    ```cpp
    // 在板级初始化代码中
    auto my_device = new iot::MyDevice();
    iot::ThingManager::GetInstance().AddThing(my_device);
    ```

**Section sources**
- [thing.h](file://main/iot/thing.h)
- [thing_manager.h](file://main/iot/thing_manager.h)
- [mqtt_set.md](file://main/notifications/mqtt_set.md#L61-L101)

## 具体设备实现分析：音乐播放器

`MusicPlayerThing` 是一个具体的物联网设备实现，用于控制音乐播放器的 UI 界面。

### 类结构与初始化

`MusicPlayerThing` 继承自 `Thing`，并在其构造函数中定义了两个方法：`Show` 和 `Hide`。

```cpp
// music_player.cc
MusicPlayerThing::MusicPlayerThing() : Thing("MusicPlayer", "音乐播放器界面控制") {
    // 注册Show方法
    std::vector<Parameter> show_params = {
        Parameter("duration_ms", "显示持续时间（毫秒）", kValueTypeNumber, false),
        Parameter("song_title", "歌曲标题", kValueTypeString, false),
        Parameter("artist_name", "艺术家名称", kValueTypeString, false)
    };
    methods_.AddMethod("Show", "显示音乐播放器界面", ParameterList(show_params), [this](const ParameterList& parameters) {
        HandleShowMethod(parameters);
    });
    
    // 注册Hide方法
    methods_.AddMethod("Hide", "隐藏音乐播放器界面", ParameterList(), [this](const ParameterList& parameters) {
        HandleHideMethod(parameters);
    });
}
```

### 控制逻辑

- **Show 方法**: 接收 `duration_ms`, `song_title`, `artist_name` 等可选参数，调用 `g_music_player_instance->SetSongInfo()` 设置歌曲信息，然后调用 `g_music_player_instance->Show()` 显示播放器界面。
- **Hide 方法**: 调用 `g_music_player_instance->Hide()` 隐藏播放器界面。

### 完整控制流程示例

1.  **外部指令**:
    ```json
    {
      "name": "MusicPlayer",
      "method": "Show",
      "parameters": {
        "song_title": "夜曲",
        "artist_name": "周杰伦",
        "duration_ms": 60000
      }
    }
    ```
2.  **指令分发**: `ThingManager` 根据 `name` 找到 `MusicPlayerThing` 实例。
3.  **方法执行**: `MusicPlayerThing::InvokeSync` 找到 `Show` 方法，解析参数，然后执行其回调函数。
4.  **硬件控制**: 回调函数调用 `HandleShowMethod`，该函数解析参数并调用 `ui::MusicPlayerUI` 的 API 来更新 UI。
5.  **结果上报**: 如果 `Show` 操作成功，`InvokeSync` 返回 `true`，协议层调用 `PublishAck` 发送一个带 `message_id` 的ACK消息。服务器回复 `ack_receipt` 后，设备端清理待确认列表。

**Section sources**
- [music_player.cc](file://main/iot/things/music_player.cc#L0-L262)
- [music_player.h](file://main/iot/things/music_player.h#L0-L32)