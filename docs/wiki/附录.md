# 附录

<cite>
**本文档中引用的文件**   
- [wake_word_detect.h](file://main/audio_processing/wake_word_detect.h)
- [wake_word_detect.cc](file://main/audio_processing/wake_word_detect.cc)
- [ota.h](file://main/ota.h)
- [ota.cc](file://main/ota.cc)
- [lcd_display.cc](file://main/display/lcd_display.cc)
- [settings.h](file://main/settings.h)
- [settings.cc](file://main/settings.cc)
- [requirements.txt](file://requirements.txt)
- [README.md](file://README.md)
</cite>

## 目录
1. [术语表](#术语表)
2. [常见问题解答（FAQ）](#常见问题解答faq)
3. [贡献指南](#贡献指南)
4. [依赖库版本清单与兼容性矩阵](#依赖库版本清单与兼容性矩阵)
5. [关键设计决策与未来发展方向](#关键设计决策与未来发展方向)

## 术语表

本节定义了项目中使用的关键专业术语。

- **唤醒词 (Wake Word)**: 指用于激活语音助手的特定词语，例如“小智”或“Hello XiaoZhi”。当设备的语音识别模块检测到该词语时，会触发后续的语音交互流程。其功能实现在 `wake_word_detect.h` 和 `wake_word_detect.cc` 文件中，利用 ESP-SR 离线语音唤醒技术。
- **OTA (Over-The-Air)**: 指空中下载技术，允许设备通过无线网络（如 Wi-Fi）接收并安装固件更新。项目中的 OTA 功能由 `ota.h` 和 `ota.cc` 文件实现，负责检查新版本、下载固件并执行升级。
- **LVGL (Light and Versatile Graphics Library)**: 一个轻量级且功能丰富的嵌入式图形库，用于在资源受限的设备（如 ESP32）上创建复杂的用户界面。本项目使用 LVGL 来驱动 OLED 和 LCD 显示屏，显示对话内容、表情和系统状态。相关代码位于 `main/display` 目录下，如 `lcd_display.cc`。
- **NVS (Non-Volatile Storage)**: 非易失性存储，是 ESP-IDF 提供的一种用于在闪存中存储键值对数据的 API。项目使用 NVS 来持久化存储设备的配置信息、Client-Id 和状态，确保设备重启后数据不丢失。`settings.h` 和 `settings.cc` 文件封装了对 NVS 的读写操作。

## 常见问题解答（FAQ）

本节解答开发者在使用本项目时最常遇到的问题。

### 如何解决烧录失败？

烧录失败可能由多种原因引起：
1.  **驱动问题**：确保已为您的开发板安装正确的 USB 转串口驱动（如 CP210x 或 CH340 驱动）。
2.  **连接问题**：检查 USB 线缆和开发板连接是否牢固。尝试更换 USB 线缆或使用不同的 USB 端口。
3.  **引脚状态**：某些开发板（如 ESP32-S3）在烧录时需要特定的 GPIO 引脚（如 GPIO0）被拉低。请查阅您开发板的文档，确认是否需要手动进入烧录模式。
4.  **端口选择**：在烧录工具（如 `flash.sh`）中，确保选择了正确的串口端口。
5.  **固件兼容性**：确认您烧录的固件与您的硬件型号完全匹配。

### 为什么语音唤醒不灵敏？

语音唤醒不灵敏可能与以下因素有关：
1.  **麦克风增益**：检查音频编解码器（Audio Codec）的配置，确保麦克风输入增益（gain）设置得当。增益过低会导致信号太弱，过高则可能引入噪声。
2.  **环境噪声**：嘈杂的环境会干扰唤醒词检测。项目使用了 AFE（Acoustic Front-End）技术来处理回声消除（AEC）和噪声抑制（NS），但极端噪声仍可能影响效果。
3.  **唤醒词模型**：确保使用的唤醒词模型（如 `wakenet_model_`）是为您的硬件和麦克风阵列优化的。不同的硬件配置可能需要不同的模型。
4.  **代码配置**：检查 `main/boards` 目录下对应开发板的 `config.json` 文件，确认 `CONFIG_USE_WAKE_WORD_DETECT` 选项已启用（设置为 `y`）。

### 如何增加新的显示分辨率支持？

要为新显示屏增加分辨率支持，通常需要：
1.  **创建新的开发板配置**：在 `main/boards` 目录下创建一个新文件夹，例如 `my_new_display`。
2.  **配置显示参数**：在新文件夹中创建 `config.json` 文件，定义目标显示屏的分辨率（`width` 和 `height`）、颜色格式、引脚连接等。
3.  **实现显示驱动**：创建一个 C++ 源文件（如 `my_new_display.cc`），继承自 `LcdDisplay` 或 `OledDisplay` 基类，并实现具体的初始化和控制逻辑。
4.  **集成 LVGL**：在显示驱动的初始化函数中，正确调用 LVGL 端口初始化函数（如 `lvgl_port_init`）和添加显示屏函数（如 `lvgl_port_add_disp`），并将配置的分辨率传递给 LVGL。
5.  **注册开发板**：确保主应用程序能够识别并使用这个新的开发板配置。

## 贡献指南

欢迎所有开发者为本项目做出贡献。请遵循以下规范。

### 代码风格规范
- **语言**：使用 C++11 标准。
- **风格**：遵循 Google C++ 代码风格指南。使用 `clang-format` 工具进行代码格式化。
- **命名**：类名采用 `PascalCase`，函数和变量名采用 `snake_case`。
- **注释**：关键函数和复杂逻辑需添加清晰的中文或英文注释。

### 提交流程
1.  Fork 本仓库。
2.  在本地创建新分支：`git checkout -b feature/your-feature-name`。
3.  进行代码修改和测试。
4.  提交更改：`git commit -m "描述你的更改"`。
5.  推送到你的 Fork：`git push origin feature/your-feature-name`。
6.  在 GitHub 上创建 Pull Request。

### 测试要求
- 所有新功能必须包含相应的单元测试或集成测试。
- 在提交前，确保所有现有测试用例都能通过。
- 对于硬件相关的更改，应在实际设备上进行充分的功能测试。

### 代码审查标准
- **功能性**：代码是否正确实现了预期功能。
- **可读性**：代码是否清晰、易于理解。
- **健壮性**：是否处理了可能的错误和边界情况。
- **性能**：代码是否高效，避免不必要的资源消耗。
- **一致性**：是否遵循了项目的代码风格和架构设计。

## 依赖库版本清单与兼容性矩阵

### 依赖库版本清单
项目的主要 Python 依赖库及其版本要求如下，定义于根目录的 `requirements.txt` 文件中：

```plaintext
# 现有依赖
PySide6>=6.5.0
requests>=2.28.0
pyserial>=3.5

# 新增用户管理系统依赖
PyMySQL>=1.0.2
bcrypt>=4.0.1
configparser>=5.3.0

# 可选：更好的MySQL连接器
# mysql-connector-python>=8.0.33

# 开发和测试依赖（可选）
# pytest>=7.0.0
# pytest-qt>=4.2.0
```

### 兼容性矩阵
| 组件 | 兼容版本 | 备注 |
| :--- | :--- | :--- |
| **ESP-IDF** | 5.3 或以上 | 编译固件所必需的开发框架。 |
| **Python** | 3.8 或以上 | 运行脚本（如 `gen_lang.py`, `release.py`）所必需。 |
| **PySide6** | 6.5.0 或以上 | 用于构建图形化工具。 |
| **requests** | 2.28.0 或以上 | 用于 HTTP 网络请求。 |
| **pyserial** | 3.5 或以上 | 用于串口通信。 |

## 关键设计决策与未来发展方向

### 关键设计决策
1.  **离线唤醒，云端推理**：采用 ESP-SR 实现离线语音唤醒，保证了低延迟和隐私性；而复杂的语音识别（ASR）和语言模型（LLM）推理则在云端完成，利用了强大的计算资源。
2.  **模块化硬件抽象**：通过 `main/boards` 目录下的多个子目录，实现了对不同硬件开发板的适配。每个开发板都有独立的配置和驱动代码，便于扩展和维护。
3.  **持久化配置管理**：使用 NVS 存储关键配置（如 Client-Id），并通过 `Settings` 类进行封装，简化了数据的存取操作，并保证了数据的持久性。
4.  **流式通信协议**：采用 WebSocket 协议进行设备与服务器之间的实时、双向通信，支持流式语音对话，提供了更自然的交互体验。

### 未来发展方向
1.  **增强本地智能**：探索在设备端运行更小规模的 LLM 模型，实现部分功能的离线化，减少对网络的依赖。
2.  **多模态交互**：集成摄像头，实现视觉识别功能，使设备能够“看”到用户和环境，提供更丰富的交互方式。
3.  **更广泛的硬件支持**：持续增加对新型号开发板和传感器的支持，扩大项目的适用范围。
4.  **优化能效**：深入研究低功耗模式（如 Tickless Idle），延长使用电池供电设备的续航时间。
5.  **改进用户体验**：优化 UI/UX 设计，提供更流畅、更人性化的交互界面和语音反馈。