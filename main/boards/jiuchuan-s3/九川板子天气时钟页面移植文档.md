# 九川板子天气时钟页面移植文档

## 目录
- [概述](#概述)
- [功能架构](#功能架构)
- [触发机制](#触发机制)
- [UI布局详解](#ui布局详解)
- [数据更新逻辑](#数据更新逻辑)
- [完整代码实现](#完整代码实现)
- [移植步骤](#移植步骤)
- [性能参数](#性能参数)

---

## 概述

天气时钟页面是九川板子的省电模式功能之一，当设备空闲30秒后自动进入该模式。页面包含：
- 实时时钟显示（小时:分钟）
- 公历日期和星期
- 农历日期和干支年
- 宜忌信息（黄历）
- 实时天气信息
- 详细气象参数（体感温度、湿度、风力、风向）

---

## 功能架构

```
九川板子启动
    ↓
初始化省电定时器
    ↓
【空闲30秒】→ 进入天气时钟模式
    ↓
创建时钟屏幕（clock_screen_）
    ↓
启动定时器：
  - 时钟更新定时器（1秒/次）
  - 天气更新定时器（1小时/次）
    ↓
后台任务：
  - 农历获取任务（24小时/次）
```

---

## 触发机制

### 1. 省电定时器初始化

**文件位置：** `main/boards/jiuchuang-s3/jiuchuang_dev_board.cc`

```cpp
void InitializePowerSaveTimer() {
    // 创建省电定时器
    // 参数：浅睡眠时间(-1禁用), 时钟模式(30秒), 降低亮度(60秒), 深度休眠(180秒)
    power_save_timer_ = new PowerSaveTimer(-1, 30, 60, 180);
    
    // 设置进入时钟模式的回调（30秒后触发）
    power_save_timer_->OnEnterClockMode([this]() {
        ESP_LOGI(TAG, "Entering weather clock mode");
        display_->SetChatMessage("system", "");      // 清空聊天消息
        display_->SetClockMode(true);                // 启用天气时钟模式
    });
    
    // 设置退出时钟模式的回调
    power_save_timer_->OnExitClockMode([this]() {
        ESP_LOGI(TAG, "Exiting weather clock mode");
        display_->SetClockMode(false);               // 禁用天气时钟模式
        display_->SetChatMessage("system", "");      // 清空聊天消息
        display_->SetEmotion("neutral");             // 设置中性表情
        GetBacklight()->RestoreBrightness();         // 恢复屏幕亮度
    });
    
    power_save_timer_->SetEnabled(true);  // 启用省电定时器
}
```

### 2. 唤醒机制

任何按键操作都会调用 `power_save_timer_->WakeUp()`，退出时钟模式：

```cpp
// 电源按键单击
pwr_button_.OnClick([this]() {
    power_save_timer_->WakeUp();  // 唤醒设备，退出时钟/睡眠模式
    // ...其他逻辑
});

// 音量加/减按键
wifi_button.OnClick([this]() {
    power_save_timer_->WakeUp();
    // ...音量调节
});
```

---

## UI布局详解

### 整体布局结构

```
┌─────────────────────────────────────┐
│  顶部区域 (240x40)                  │
│  城市名称          日期 + 星期      │
├─────────────────────────────────────┤
│                                     │
│  主时间卡片 (220x95)                │
│  ┌─────────────┬─────────────┐     │
│  │ 时间 00:00  │ 宜：- -     │     │
│  │             │ 忌：- -     │     │
│  └─────────────┴─────────────┘     │
│         农历：腊月廿三              │
│                                     │
├─────────────────────────────────────┤
│  天气信息卡片 (220x65)              │
│  [图标] 多云  22°  15°/25°          │
├─────────────────────────────────────┤
│  详细参数区域 (220x70)              │
│  体感  湿度  风力  风向             │
│  26°   72%   3级   东风             │
└─────────────────────────────────────┘
```

### UI元素层级和坐标

**文件位置：** `main/display/lcd_display.cc: SetupWeatherClock()`

```cpp
void LcdDisplay::SetupWeatherClock() {
    // ===== 1. 顶部区域：城市和日期 =====
    lv_obj_t* top_area = lv_obj_create(clock_screen_);
    lv_obj_set_size(top_area, 240, 40);
    lv_obj_set_style_bg_opa(top_area, LV_OPA_0, 0);           // 透明背景
    lv_obj_set_style_border_width(top_area, 0, 0);
    lv_obj_align(top_area, LV_ALIGN_TOP_MID, 0, 10);          // 顶部偏移10px
    
    // 城市名称 - 左对齐
    weather_city_ = lv_label_create(top_area);
    lv_obj_set_style_text_font(weather_city_, fonts_.text_font, 0);
    lv_obj_set_style_text_color(weather_city_, lv_color_make(60, 60, 60), 0);
    lv_label_set_text(weather_city_, "龙岩");
    lv_obj_align(weather_city_, LV_ALIGN_LEFT_MID, 10, 0);
    
    // 日期标签（包含星期）- 右对齐
    clock_date_label_ = lv_label_create(top_area);
    lv_obj_set_style_text_font(clock_date_label_, fonts_.text_font, 0);
    lv_obj_set_style_text_color(clock_date_label_, lv_color_make(80, 80, 80), 0);
    lv_label_set_text(clock_date_label_, "12月25日 周一");
    lv_obj_align(clock_date_label_, LV_ALIGN_RIGHT_MID, -10, 0);
    
    // ===== 2. 主时间卡片 =====
    lv_obj_t* main_card = lv_obj_create(clock_screen_);
    lv_obj_set_size(main_card, 220, 95);
    lv_obj_set_style_bg_color(main_card, lv_color_make(245, 245, 245), 0);
    lv_obj_set_style_radius(main_card, 15, 0);                // 圆角半径15px
    lv_obj_set_style_shadow_width(main_card, 10, 0);          // 阴影宽度
    lv_obj_set_style_shadow_opa(main_card, LV_OPA_10, 0);     // 阴影透明度10%
    lv_obj_set_style_shadow_ofs_y(main_card, 3, 0);           // 阴影Y偏移3px
    lv_obj_align(main_card, LV_ALIGN_TOP_MID, 0, 50);
    
    // 时间和宜忌横向排列容器
    lv_obj_t* time_row = lv_obj_create(main_card);
    lv_obj_set_size(time_row, 210, 50);
    lv_obj_set_style_bg_opa(time_row, LV_OPA_TRANSP, 0);
    lv_obj_set_flex_flow(time_row, LV_FLEX_FLOW_ROW);
    lv_obj_set_flex_align(time_row, LV_FLEX_ALIGN_START, 
                          LV_FLEX_ALIGN_CENTER, LV_FLEX_ALIGN_CENTER);
    lv_obj_align(time_row, LV_ALIGN_TOP_LEFT, 10, 5);

    // 时间标签 - 使用40号字体
    clock_time_label_ = lv_label_create(time_row);
    lv_obj_set_style_text_font(clock_time_label_, &time40, 0);
    lv_obj_set_style_text_color(clock_time_label_, lv_color_make(30, 30, 30), 0);
    lv_label_set_text(clock_time_label_, "00:00");
    lv_obj_set_width(clock_time_label_, 105);

    // 宜忌竖直容器
    lv_obj_t* yi_ji_col = lv_obj_create(time_row);
    lv_obj_set_size(yi_ji_col, 90, 45);
    lv_obj_set_style_bg_opa(yi_ji_col, LV_OPA_TRANSP, 0);
    lv_obj_set_flex_flow(yi_ji_col, LV_FLEX_FLOW_COLUMN);
    lv_obj_set_flex_align(yi_ji_col, LV_FLEX_ALIGN_START, 
                          LV_FLEX_ALIGN_START, LV_FLEX_ALIGN_START);

    // 宜标签
    yi_label_ = lv_label_create(yi_ji_col);
    lv_obj_set_style_text_font(yi_label_, fonts_.text_font, 0);
    lv_obj_set_style_text_color(yi_label_, lv_color_make(30, 120, 30), 0);  // 绿色
    lv_label_set_text(yi_label_, "宜：- -");
    lv_obj_set_width(yi_label_, 90);

    // 忌标签
    ji_label_ = lv_label_create(yi_ji_col);
    lv_obj_set_style_text_font(ji_label_, fonts_.text_font, 0);
    lv_obj_set_style_text_color(ji_label_, lv_color_make(180, 30, 30), 0);  // 红色
    lv_label_set_text(ji_label_, "忌：- -");
    lv_obj_set_width(ji_label_, 90);

    // 农历日期标签 - 放在时间下方
    lunar_date_label_ = lv_label_create(main_card);
    lv_obj_set_style_text_font(lunar_date_label_, fonts_.text_font, 0);
    lv_obj_set_style_text_color(lunar_date_label_, lv_color_make(100, 100, 100), 0);
    lv_label_set_text(lunar_date_label_, "腊月廿三");
    lv_obj_set_width(lunar_date_label_, 200);
    lv_label_set_long_mode(lunar_date_label_, LV_LABEL_LONG_SCROLL);  // 滚动模式
    lv_obj_set_style_text_align(lunar_date_label_, LV_TEXT_ALIGN_CENTER, 0);
    lv_obj_align_to(lunar_date_label_, time_row, LV_ALIGN_OUT_BOTTOM_MID, 0, 5);
    
    // ===== 3. 天气信息卡片 =====
    lv_obj_t* weather_card = lv_obj_create(clock_screen_);
    lv_obj_set_size(weather_card, 220, 65);
    lv_obj_set_style_bg_color(weather_card, lv_color_white(), 0);
    lv_obj_set_style_radius(weather_card, 12, 0);
    lv_obj_set_style_border_width(weather_card, 1, 0);
    lv_obj_set_style_border_color(weather_card, lv_color_make(230, 230, 230), 0);
    lv_obj_set_style_pad_all(weather_card, 8, 0);
    lv_obj_align(weather_card, LV_ALIGN_TOP_MID, 0, 155);
    
    // 使用Flex布局 - 水平排列所有元素
    lv_obj_set_flex_flow(weather_card, LV_FLEX_FLOW_ROW);
    lv_obj_set_flex_align(weather_card, LV_FLEX_ALIGN_SPACE_EVENLY, 
                          LV_FLEX_ALIGN_CENTER, LV_FLEX_ALIGN_CENTER);
    
    // 天气图标 - 45x45像素
    weather_icon_ = lv_image_create(weather_card);
    lv_image_set_src(weather_icon_, &cloud);
    lv_obj_set_size(weather_icon_, 45, 45);
    
    // 天气描述文字
    weather_text_ = lv_label_create(weather_card);
    lv_obj_set_style_text_font(weather_text_, fonts_.text_font, 0);
    lv_obj_set_style_text_color(weather_text_, lv_color_make(60, 60, 60), 0);
    lv_label_set_text(weather_text_, "多云");
    
    // 当前温度 - 30号字体
    weather_temp_ = lv_label_create(weather_card);
    lv_obj_set_style_text_font(weather_temp_, &time30, 0);
    lv_obj_set_style_text_color(weather_temp_, lv_color_make(30, 30, 30), 0);
    lv_label_set_text(weather_temp_, "22°");
    
    // 温度范围
    lv_obj_t* temp_range = lv_label_create(weather_card);
    lv_obj_set_style_text_font(temp_range, fonts_.text_font, 0);
    lv_obj_set_style_text_color(temp_range, lv_color_make(120, 120, 120), 0);
    lv_label_set_text(temp_range, "15°/25°");
    temp_range_label_ = temp_range;  // 保存引用用于更新
    
    // ===== 4. 详细天气参数 =====
    lv_obj_t* detail_container = lv_obj_create(clock_screen_);
    lv_obj_set_size(detail_container, 220, 70);
    lv_obj_set_style_bg_color(detail_container, lv_color_make(250, 250, 250), 0);
    lv_obj_set_style_radius(detail_container, 10, 0);
    lv_obj_set_style_pad_all(detail_container, 10, 0);
    lv_obj_align(detail_container, LV_ALIGN_BOTTOM_MID, 0, -30);
    
    // 使用水平布局，确保均匀分布
    lv_obj_set_flex_flow(detail_container, LV_FLEX_FLOW_ROW);
    lv_obj_set_flex_align(detail_container, LV_FLEX_ALIGN_SPACE_EVENLY, 
                          LV_FLEX_ALIGN_CENTER, LV_FLEX_ALIGN_CENTER);
    
    // 体感温度容器
    lv_obj_t* feels_container = lv_obj_create(detail_container);
    lv_obj_set_size(feels_container, 50, 50);
    lv_obj_set_style_bg_opa(feels_container, LV_OPA_0, 0);
    lv_obj_set_flex_flow(feels_container, LV_FLEX_FLOW_COLUMN);
    lv_obj_set_flex_align(feels_container, LV_FLEX_ALIGN_CENTER, 
                          LV_FLEX_ALIGN_CENTER, LV_FLEX_ALIGN_CENTER);
    
    lv_obj_t* feels_title = lv_label_create(feels_container);
    lv_obj_set_style_text_color(feels_title, lv_color_make(100, 100, 100), 0);
    lv_label_set_text(feels_title, "体感");
    
    weather_feels_label_ = lv_label_create(feels_container);
    lv_obj_set_style_text_color(weather_feels_label_, lv_color_make(60, 60, 60), 0);
    lv_label_set_text(weather_feels_label_, "26°");
    
    // 湿度、风力、风向容器 - 结构相同，省略具体代码
    // ... 参考完整实现
}
```

---

## 数据更新逻辑

### 1. 时钟更新（1秒/次）

**定时器创建：**

```cpp
// 在 SetClockMode(true) 中创建
clock_lvgl_timer_ = lv_timer_create(clock_timer_callback, 1000, this);
```

**更新函数：**

```cpp
void LcdDisplay::UpdateClockDisplay() {
    if (!clock_mode_enabled_ || clock_screen_ == nullptr) {
        return;
    }
    
    // 1. 更新时间显示
    time_t now = time(NULL);
    struct tm* timeinfo = localtime(&now);
    char time_str[16];
    strftime(time_str, sizeof(time_str), "%H:%M", timeinfo);
    lv_label_set_text(clock_time_label_, time_str);
    
    // 2. 更新日期和星期
    if (clock_date_label_ != nullptr) {
        char date_str[64];
        const char* weekdays[] = {"日", "一", "二", "三", "四", "五", "六"};
        strftime(date_str, sizeof(date_str), "%m月%d日", timeinfo);
        std::string full_date = std::string(date_str) + " 周" + weekdays[timeinfo->tm_wday];
        lv_label_set_text(clock_date_label_, full_date.c_str());
    }
    
    // 3. 获取并显示农历信息和干支年
    if (lunar_date_label_ != nullptr) {
        std::lock_guard<std::mutex> lock(g_lunar_mutex);
        std::string lunar_display;
        if (!g_lunar_cache.ganzhi_year.empty()) {
            lunar_display = g_lunar_cache.ganzhi_year + "年 " + g_lunar_cache.lunar_str;
        } else {
            lunar_display = g_lunar_cache.lunar_str;
        }
        lv_label_set_text(lunar_date_label_, lunar_display.c_str());
    }
    
    // 4. 显示宜/忌
    if (yi_label_ && ji_label_) {
        std::string yi_str = "宜：- -";
        std::string ji_str = "忌：- -";
        {
            std::lock_guard<std::mutex> lock(g_lunar_mutex);
            if (!g_lunar_yi.empty()) {
                yi_str = "宜：" + g_lunar_yi[0];
            }
            if (!g_lunar_ji.empty()) {
                ji_str = "忌：" + g_lunar_ji[0];
            }
        }
        lv_label_set_text(yi_label_, yi_str.c_str());
        lv_label_set_text(ji_label_, ji_str.c_str());
    }
    
    // 5. 每小时触发天气更新（通过独立任务）
    static time_t last_weather_update = 0;
    if ((now - last_weather_update) > (60 * 60)) {
        // 创建单独的任务更新天气，避免在定时器任务中执行耗时操作
        xTaskCreate(WeatherUpdateTask, "WeatherUpdate", 8192 * 3, param, 2, NULL);
        last_weather_update = now;
    }
}
```

### 2. 天气更新（1小时/次）

**数据源：** 高德地图天气API

**更新流程：**

```cpp
void LcdDisplay::UpdateWeatherData() {
    ESP_LOGI(TAG, "Updating weather data");
    
    // 第一步：通过IP定位获取城市编码
    auto http = Board::GetInstance().CreateHttp();
    std::string adcode = "";
    
    if (http->Open("GET", "https://restapi.amap.com/v3/ip?key=eac978c2fa1693791f287a32528e6d7e")) {
        std::string response = http->GetBody();
        http->Close();
        
        // 解析JSON获取城市编码
        cJSON *root = cJSON_Parse(response.c_str());
        if (root) {
            cJSON *adcode_json = cJSON_GetObjectItem(root, "adcode");
            if (adcode_json && adcode_json->valuestring) {
                adcode = adcode_json->valuestring;
            }
            cJSON_Delete(root);
        }
    }
    
    // 如果IP定位失败，使用默认值
    if (adcode.empty()) {
        adcode = "110105";  // 默认北京市朝阳区
    }
    
    // 第二步：使用城市编码获取天气预报
    delete http;
    http = Board::GetInstance().CreateHttp();
    std::string weather_url = "https://restapi.amap.com/v3/weather/weatherInfo?key=xxx&city=" 
                             + adcode + "&extensions=all";
    
    if (http->Open("GET", weather_url)) {
        std::string response = http->GetBody();
        http->Close();
        
        // 解析天气预报数据
        cJSON *root = cJSON_Parse(response.c_str());
        if (root) {
            cJSON *forecasts = cJSON_GetObjectItem(root, "forecasts");
            if (forecasts && cJSON_IsArray(forecasts)) {
                cJSON *forecast = cJSON_GetArrayItem(forecasts, 0);
                
                // 获取城市名称
                cJSON *city = cJSON_GetObjectItem(forecast, "city");
                if (city && city->valuestring) {
                    weather_data_.city = city->valuestring;
                }
                
                // 获取今日天气
                cJSON *casts = cJSON_GetObjectItem(forecast, "casts");
                if (casts && cJSON_IsArray(casts)) {
                    cJSON *today = cJSON_GetArrayItem(casts, 0);
                    
                    // 解析各项数据
                    cJSON *dayweather = cJSON_GetObjectItem(today, "dayweather");
                    cJSON *daytemp = cJSON_GetObjectItem(today, "daytemp");
                    cJSON *nighttemp = cJSON_GetObjectItem(today, "nighttemp");
                    cJSON *daywind = cJSON_GetObjectItem(today, "daywind");
                    cJSON *daypower = cJSON_GetObjectItem(today, "daypower");
                    
                    // 保存到weather_data_结构
                    // ...
                }
            }
            cJSON_Delete(root);
        }
    }
    
    // 第三步：获取实况天气数据
    delete http;
    http = Board::GetInstance().CreateHttp();
    std::string live_weather_url = "https://restapi.amap.com/v3/weather/weatherInfo?key=xxx&city=" 
                                   + adcode + "&extensions=base";
    
    if (http->Open("GET", live_weather_url)) {
        std::string response = http->GetBody();
        http->Close();
        
        // 解析实况温度、湿度等
        cJSON *root = cJSON_Parse(response.c_str());
        if (root) {
            cJSON *lives = cJSON_GetObjectItem(root, "lives");
            if (lives && cJSON_IsArray(lives)) {
                cJSON *live = cJSON_GetArrayItem(lives, 0);
                
                cJSON *temperature = cJSON_GetObjectItem(live, "temperature");
                cJSON *humidity = cJSON_GetObjectItem(live, "humidity");
                // ...
            }
            cJSON_Delete(root);
        }
    }
    
    weather_data_.dataValid = true;
    delete http;
    
    // 更新天气显示
    UpdateWeatherDisplay();
}
```

**天气显示更新：**

```cpp
void LcdDisplay::UpdateWeatherDisplay() {
    if (!weather_data_.dataValid) {
        return;
    }
    
    DisplayLockGuard lock(this);
    
    // 更新城市名称
    lv_label_set_text(weather_city_, weather_data_.city.c_str());
    
    // 更新天气描述
    lv_label_set_text(weather_text_, weather_data_.text.c_str());
    
    // 更新当前温度
    std::string current_temp = weather_data_.temp + "°";
    lv_label_set_text(weather_temp_, current_temp.c_str());
    
    // 更新温度范围
    std::string temp_range = weather_data_.lowTemp + "°/" + weather_data_.highTemp + "°";
    lv_label_set_text(temp_range_label_, temp_range.c_str());
    
    // 更新天气图标
    const lv_image_dsc_t* icon = getWeatherIcon(weather_data_.icon);
    lv_image_set_src(weather_icon_, icon);
    
    // 更新详细参数
    lv_label_set_text(weather_feels_label_, (weather_data_.feelsLike + "°").c_str());
    lv_label_set_text(weather_humidity_label_, (weather_data_.humidity + "%").c_str());
    lv_label_set_text(weather_wind_label_, (weather_data_.windScale + "级").c_str());
    lv_label_set_text(weather_vis_label_, weather_data_.windDir.c_str());
}
```

### 3. 农历更新（后台任务）

**任务创建：**

```cpp
// 在 SpiLcdDisplay 构造函数中创建
xTaskCreate(LunarFetchTask, "LunarFetchTask", 8192 * 2, nullptr, 3, nullptr);
```

**农历获取任务：**

```cpp
static void LunarFetchTask(void*) {
    // 等待WiFi和网络栈初始化完成
    vTaskDelay(15000 / portTICK_PERIOD_MS);

    while (1) {
        // 检查WiFi连接状态
        wifi_ap_record_t ap_info;
        bool wifi_connected = (esp_wifi_sta_get_ap_info(&ap_info) == ESP_OK);
        
        if (!wifi_connected) {
            vTaskDelay(10000 / portTICK_PERIOD_MS);  // 10秒后重试
            continue;
        }

        // 检查是否需要更新（日期变化）
        time_t now = time(NULL);
        struct tm* timeinfo = localtime(&now);
        char ymd[16];
        strftime(ymd, sizeof(ymd), "%Y-%m-%d", timeinfo);
        std::string today = ymd;
        
        bool need_query = false;
        {
            std::lock_guard<std::mutex> lock(g_lunar_mutex);
            if (g_lunar_cache.date != today) {
                need_query = true;
            }
        }
        
        if (need_query) {
            // 调用ALAPI农历接口
            std::string alapi_token = "aswutdoxli64xvjqy3rxswygvdb75u";
            std::string url = "https://v2.alapi.cn/api/lunar?token=" + alapi_token;
            
            auto http = Board::GetInstance().CreateHttp();
            if (http && http->Open("GET", url)) {
                std::string response = http->GetBody();
                http->Close();
                delete http;
                
                // 解析JSON
                cJSON* root = cJSON_Parse(response.c_str());
                if (root) {
                    cJSON* data = cJSON_GetObjectItem(root, "data");
                    if (data) {
                        // 获取农历月日
                        cJSON* lunar_month = cJSON_GetObjectItem(data, "lunar_month_chinese");
                        cJSON* lunar_day = cJSON_GetObjectItem(data, "lunar_day_chinese");
                        std::string lunar_str = std::string(lunar_month->valuestring) 
                                              + lunar_day->valuestring;
                        
                        // 获取干支年
                        cJSON* ganzhi_year_json = cJSON_GetObjectItem(data, "ganzhi_year");
                        std::string ganzhi_year = ganzhi_year_json->valuestring;
                        
                        // 解析宜/忌
                        cJSON* yi_arr = cJSON_GetObjectItem(data, "yi");
                        cJSON* ji_arr = cJSON_GetObjectItem(data, "ji");
                        
                        std::lock_guard<std::mutex> lock(g_lunar_mutex);
                        g_lunar_yi.clear();
                        g_lunar_ji.clear();
                        
                        // 解析宜
                        if (yi_arr && cJSON_IsArray(yi_arr)) {
                            for (int i = 0; i < cJSON_GetArraySize(yi_arr); ++i) {
                                cJSON* item = cJSON_GetArrayItem(yi_arr, i);
                                if (item && item->valuestring) {
                                    g_lunar_yi.push_back(item->valuestring);
                                }
                            }
                        }
                        
                        // 解析忌
                        if (ji_arr && cJSON_IsArray(ji_arr)) {
                            for (int i = 0; i < cJSON_GetArraySize(ji_arr); ++i) {
                                cJSON* item = cJSON_GetArrayItem(ji_arr, i);
                                if (item && item->valuestring) {
                                    g_lunar_ji.push_back(item->valuestring);
                                }
                            }
                        }
                        
                        // 更新缓存
                        g_lunar_cache.date = today;
                        g_lunar_cache.lunar_str = lunar_str;
                        g_lunar_cache.ganzhi_year = ganzhi_year;
                    }
                    cJSON_Delete(root);
                }
            }
        }
        
        // 每24小时检查一次
        vTaskDelay(24 * 60 * 60 * 1000 / portTICK_PERIOD_MS);
    }
}
```

---

## 完整代码实现

### 关键数据结构

```cpp
// 天气数据结构
struct WeatherData {
    bool dataValid = false;
    std::string city;              // 城市名称
    std::string text;              // 天气描述
    std::string temp;              // 当前温度
    std::string feelsLike;         // 体感温度
    std::string windDir;           // 风向
    std::string windScale;         // 风力等级
    std::string humidity;          // 湿度
    std::string vis;               // 能见度
    std::string icon;              // 天气图标代码
    std::string lowTemp;           // 最低温度
    std::string highTemp;          // 最高温度
    std::string updateTime;        // 更新时间
};

// 农历缓存结构
struct LunarCache {
    std::string date;              // YYYY-MM-DD
    std::string lunar_str;         // 农历字符串
    std::string ganzhi_year;       // 干支年
};

// 全局变量
static LunarCache g_lunar_cache;
static std::mutex g_lunar_mutex;
static std::vector<std::string> g_lunar_yi;   // 宜
static std::vector<std::string> g_lunar_ji;   // 忌
```

### 类成员变量

```cpp
class LcdDisplay : public Display {
private:
    // 时钟模式相关
    bool clock_mode_enabled_ = false;
    lv_obj_t* clock_screen_ = nullptr;
    lv_obj_t* main_screen_ = nullptr;
    
    // 时钟UI元素
    lv_obj_t* clock_time_label_ = nullptr;
    lv_obj_t* clock_date_label_ = nullptr;
    lv_obj_t* lunar_date_label_ = nullptr;
    lv_obj_t* yi_label_ = nullptr;
    lv_obj_t* ji_label_ = nullptr;
    
    // 天气UI元素
    lv_obj_t* weather_city_ = nullptr;
    lv_obj_t* weather_icon_ = nullptr;
    lv_obj_t* weather_text_ = nullptr;
    lv_obj_t* weather_temp_ = nullptr;
    lv_obj_t* temp_range_label_ = nullptr;
    lv_obj_t* weather_feels_label_ = nullptr;
    lv_obj_t* weather_humidity_label_ = nullptr;
    lv_obj_t* weather_wind_label_ = nullptr;
    lv_obj_t* weather_vis_label_ = nullptr;
    
    // 定时器
    lv_timer_t* clock_lvgl_timer_ = nullptr;
    lv_timer_t* weather_lvgl_timer_ = nullptr;
    
    // 天气数据
    WeatherData weather_data_;
};
```

### 天气图标映射表

```cpp
// 定义天气图标映射（部分）
static const struct {
    const char* code;
    const lv_image_dsc_t* image;
} weather_icons[] = {
    {"100", &sun},              // 晴天
    {"101", &cloud},            // 多云
    {"104", &cloud},            // 阴天
    {"300", &rain},             // 阵雨
    {"302", &thunder},          // 雷阵雨
    {"305", &rain},             // 小雨
    {"400", &Snow},             // 小雪
    {"501", &fog},              // 雾
    {"502", &Dust},             // 霾
    {"999", &Negative},         // 未知
};

// 获取天气图标
const lv_image_dsc_t* getWeatherIcon(const std::string& code) {
    for (const auto& item : weather_icons) {
        if (item.code == code) {
            return item.image;
        }
    }
    return &cloud; // 默认图标
}
```

---

## 移植步骤

### 1. 添加必要的头文件和字体

```cpp
// 在 lcd_display.cc 中添加
#include <cJSON.h>
#include <esp_http_client.h>
#include <esp_wifi.h>
#include <mutex>

// 声明时钟字体
LV_FONT_DECLARE(time50);
LV_FONT_DECLARE(time40);
LV_FONT_DECLARE(time30);
LV_FONT_DECLARE(time20);

// 声明天气图标
LV_IMAGE_DECLARE(sun);
LV_IMAGE_DECLARE(cloud);
LV_IMAGE_DECLARE(rain);
LV_IMAGE_DECLARE(Snow);
LV_IMAGE_DECLARE(fog);
LV_IMAGE_DECLARE(Dust);
LV_IMAGE_DECLARE(hail);
LV_IMAGE_DECLARE(thunder);
LV_IMAGE_DECLARE(Negative);
```

### 2. 在 Display 类中添加接口

```cpp
// display.h
class Display {
public:
    virtual void SetClockMode(bool enabled) = 0;
    virtual void UpdateClockDisplay() = 0;
    virtual void UpdateWeatherData() = 0;
    virtual void UpdateWeatherDisplay() = 0;
};
```

### 3. 在 LcdDisplay 类中实现方法

按照上述完整代码实现以下方法：
- `SetupClockScreen()` - 创建时钟屏幕
- `SetupWeatherClock()` - 设置天气时钟UI
- `SetClockMode(bool enabled)` - 进入/退出时钟模式
- `UpdateClockDisplay()` - 更新时钟显示
- `UpdateWeatherData()` - 更新天气数据
- `UpdateWeatherDisplay()` - 更新天气显示
- `OnClockUpdate()` - 时钟定时器回调
- `OnWeatherUpdate()` - 天气定时器回调

### 4. 添加省电定时器支持

```cpp
// 在板级代码中添加 PowerSaveTimer
power_save_timer_ = new PowerSaveTimer(-1, 30, 60, 180);

power_save_timer_->OnEnterClockMode([this]() {
    display_->SetClockMode(true);
});

power_save_timer_->OnExitClockMode([this]() {
    display_->SetClockMode(false);
});

power_save_timer_->SetEnabled(true);
```

### 5. 配置API密钥

```cpp
// 高德地图API密钥（需要自己申请）
std::string amap_key = "your_amap_api_key";

// ALAPI农历API密钥（需要自己申请）
std::string alapi_token = "your_alapi_token";
```

### 6. 准备天气图标资源

确保以下图标文件存在：
- `main/display/Weather Icons/sun.c`
- `main/display/Weather Icons/cloud.c`
- `main/display/Weather Icons/rain.c`
- `main/display/Weather Icons/Snow.c`
- `main/display/Weather Icons/fog.c`
- `main/display/Weather Icons/Dust.c`
- `main/display/Weather Icons/hail.c`
- `main/display/Weather Icons/thunder.c`
- `main/display/Weather Icons/Negative.c`

### 7. 编译和测试

```bash
# 清理并重新编译
idf.py fullclean
idf.py build

# 烧录固件
idf.py -p COM3 flash monitor
```

---

## 性能参数

### 内存占用

| 项目 | 大小 | 说明 |
|------|------|------|
| 时钟屏幕UI对象 | ~8KB | LVGL对象和标签 |
| 天气数据结构 | ~2KB | WeatherData结构 |
| 农历缓存 | ~512B | LunarCache结构 |
| 天气图标资源 | ~30KB | 9个PNG图标转换后的数据 |
| **总计** | **~40KB** | |

### 帧率和刷新率

| 项目 | 帧率/频率 | 说明 |
|------|-----------|------|
| LVGL刷新率 | 30 FPS | LVGL默认帧率 |
| 时钟更新 | 1次/秒 | 时间和日期更新 |
| 天气更新 | 1次/小时 | HTTP请求获取天气 |
| 农历更新 | 1次/24小时 | HTTP请求获取农历 |
| UI重绘 | 仅变化时 | LVGL智能重绘 |

### 网络流量

| 项目 | 流量 | 频率 |
|------|------|------|
| IP定位请求 | ~500B | 1次/小时 |
| 天气预报请求 | ~2KB | 1次/小时 |
| 实况天气请求 | ~1KB | 1次/小时 |
| 农历请求 | ~1.5KB | 1次/24小时 |
| **每小时总计** | **~3.5KB** | |
| **每天总计** | **~85KB** | |

### 电池续航影响

假设屏幕功耗：
- 正常模式：200mW
- 时钟模式：150mW（降低亮度后100mW）
- 深度睡眠：5mW

电池容量1000mAh @ 3.7V (3.7Wh)：
- **仅正常模式**：约18.5小时
- **时钟模式（降低亮度）**：约37小时
- **混合模式（30秒空闲进入时钟）**：约25-30小时

---

## 调试技巧

### 1. 查看日志输出

```cpp
// 在关键位置添加日志
ESP_LOGI(TAG, "Entering weather clock mode");
ESP_LOGI(TAG, "Weather data updated: %s, %s°", 
         weather_data_.city.c_str(), weather_data_.temp.c_str());
ESP_LOGI(TAG, "Lunar data: %s %s", 
         g_lunar_cache.ganzhi_year.c_str(), g_lunar_cache.lunar_str.c_str());
```

### 2. 验证网络请求

```cpp
// 打印HTTP响应
ESP_LOGI(TAG, "Weather API response: %s", response.c_str());
```

### 3. 测试省电定时器

```cpp
// 修改定时器参数快速测试
power_save_timer_ = new PowerSaveTimer(-1, 5, 10, 20);  // 5秒进入时钟模式
```

### 4. LVGL对象检查

```cpp
// 检查对象是否创建成功
if (clock_time_label_ == nullptr) {
    ESP_LOGE(TAG, "Failed to create clock_time_label_");
}
```

---

## 常见问题

### Q1: 天气数据无法获取？
**A:** 检查以下几点：
1. WiFi是否连接成功
2. API密钥是否有效
3. 网络请求是否超时
4. JSON解析是否成功

### Q2: 农历显示为"加载中"？
**A:** 
- 后台任务需要15秒启动延迟
- 检查ALAPI token是否有效
- 查看是否有网络连接

### Q3: 时钟不更新？
**A:**
- 检查 `clock_lvgl_timer_` 是否创建成功
- 确认时钟模式已启用 `clock_mode_enabled_ == true`
- 查看系统时间是否同步

### Q4: UI显示错位？
**A:**
- 检查屏幕分辨率是否为240x320
- 调整各容器的坐标和尺寸
- 确认字体文件正确加载

### Q5: 内存不足？
**A:**
- 增加任务栈大小
- 优化HTTP响应缓冲区
- 及时释放HTTP客户端资源

---

## 参考资料

1. **高德地图天气API文档**
   - https://lbs.amap.com/api/webservice/guide/api/weatherinfo

2. **ALAPI农历接口文档**
   - https://www.alapi.cn/api/view/93

3. **LVGL官方文档**
   - https://docs.lvgl.io/8.3/

4. **ESP-IDF编程指南**
   - https://docs.espressif.com/projects/esp-idf/zh_CN/latest/

---

## 版本历史

| 版本 | 日期 | 更新内容 |
|------|------|----------|
| v1.0 | 2024-12-XX | 初始版本，包含基础时钟和天气功能 |
| v1.1 | 2024-12-XX | 新增宜忌显示，优化UI布局 |
| v1.2 | 2024-12-XX | 添加干支年显示，优化网络请求 |

---

## 作者和许可

**作者：** XiaoZhi Team  
**许可：** MIT License

---

*本文档包含了九川板子天气时钟页面的完整实现细节，可以直接用于其他ESP32项目的移植。如有问题，请查看源代码或联系开发团队。*

